{"mappings":"iiBAAAA,EAAA,SCAA,IAAAC,EAAAD,EAAA,S,aAgCA,IAAC,W,sBAhCKE,I,aAEFC,KAAKC,KAAO,CACVC,cAAeC,SAASC,iBAAiB,qBACzCC,WAAYF,SAASC,iBAAiB,mBAGxCJ,KAAKM,c,iBAGPC,IAAA,e,MAAA,W,WACEP,KAAKC,KAAKI,WAAWG,SAAQ,SAAAC,G,OAC3BA,EAAOC,iBAAiB,QAASC,EAAKC,mBAAmBC,KAAIF,G,OAIjEJ,IAAA,qB,MAAA,SAAmBO,GACjB,IAAMC,EAAgBD,EAAME,OAAOC,QAAQ,kBAC3CjB,KAAKC,KAAKI,WAAWG,SAAQ,SAAAC,GAC3BM,EAAcG,OAAST,EAAOS,KAC1BT,EAAOU,UAAUC,OAAQ,WACzBX,EAAOU,UAAUE,IAAK,U,IAG5BrB,KAAKC,KAAKC,cAAcM,SAAQ,SAAAc,GAC9BP,EAAcG,OAASI,EAAMC,QAAQL,KACjCI,EAAMH,UAAUC,OAAO,aACvBE,EAAMH,UAAUE,IAAI,Y,UAK7B,IChCDvB,EAAAD,EAAA,S,aCuBe,SAAA2B,EAAUC,EAAOC,EAAUC,GAKrCA,IAMAC,EANAD,KAAW,GAJfE,EAAAC,EACCC,kBADD,IAAAF,KAAAG,EAAAF,EAECG,iBAFD,IAAAD,KAAAE,EAAAJ,EAGCK,oBAHD,IAAAD,OAGgBE,EAHhBF,EAWIG,GAAY,EAGZC,EAAW,EAGf,SAASC,IACJX,GACHY,aAAaZ,E,CAgBf,SAASa,IAAuB,QAAAC,EAAAC,UAAAC,OAAZC,EAAY,IAAAC,MAAAJ,GAAAK,EAAA,EAAAA,EAAAL,EAAAK,IAAZF,EAAYE,GAAAJ,UAAAI,GAC3BC,MAAOhD,KACPiD,EAAUC,KAAKC,MAAQb,EAO3B,SAASc,IACRd,EAAWY,KAAKC,MAChBzB,EAAS2B,MAAML,EAAMH,E,CAOtB,SAASS,IACR1B,OAAYQ,C,CAfTC,IAkBCJ,IAAaE,GAAiBP,GAMlCwB,IAGDb,SAEqBH,IAAjBD,GAA8Bc,EAAUxB,EACvCQ,GAMHK,EAAWY,KAAKC,MACXpB,IACJH,EAAY2B,WAAWpB,EAAemB,EAAQF,EAAM3B,KAOrD2B,KAEwB,IAAfrB,IAYVH,EAAY2B,WACXpB,EAAemB,EAAQF,OACNhB,IAAjBD,EAA6BV,EAAQwB,EAAUxB,I,CAQlD,OAHAgB,EAAQe,OAjFCA,SAAO7B,GACkBA,IAAjC8B,GAAiC9B,GAAW,IAApC+B,oBAAR,IAAAD,KACAlB,IACAF,GAAaqB,C,EAiFPjB,C,CDpBR,IAAC,W,sBA9GKkB,I,aAEF3D,KAAKC,KAAO,CACV2D,YAAazD,SAAS0D,cAAc,yBACpCC,aAAc3D,SAASC,iBAAiB,2BAG1CJ,KAAK+D,a,iBAMPxD,IAAA,c,MAAA,WAKEiB,EAAS,IAAMxB,KAAKgE,aAAanD,KAAKb,M,IAGxCO,IAAA,e,MAAA,W,WACQ0D,EAAOjE,KAAKC,KAAK2D,YAAYM,wBAC7BC,EACJF,EAAKG,KAAO,GACZH,EAAKI,MAAQ,GACbJ,EAAKK,SACFC,OAAOC,aAAerE,SAASsE,gBAAgBC,eAClDT,EAAKU,QAAUJ,OAAOK,YAAczE,SAASsE,gBAAgBI,aAC/DC,QAAQC,IAAIZ,GAEZ,IAAIa,EAAU,KAcdb,EACKa,EAAUC,aAAY,W,OAAMtE,EAAKuE,S,GAAW,KAC7CC,cAAcH,E,IAGpBzE,IAAA,U,MAAA,WACE,IAAI0D,EAAOjE,KAAKC,KAAK2D,YAAYM,wBACjCY,QAAQC,IAAId,EAAKG,I,IA4BnB7D,IAAA,U,MAAA,W,WAKEuE,QAAQC,IAAIK,KAAKC,MAAMD,KAAKE,SAAWtF,KAAKC,KAAK6D,aAAalB,SAG9D,IAAM2C,EAAwBH,KAAKC,MACjCD,KAAKE,SAAWtF,KAAKC,KAAK6D,aAAalB,QAOzC5C,KAAKC,KAAK6D,aAAayB,GAAuBpE,UAAUE,IACtD,kBAGFkC,YAAW,WACT5C,EAAKV,KAAK6D,aAAayB,GAAuBpE,UAAUC,OACtD,iB,GAGD,I,OAKN,I,sBEhHDtB,EAAAD,EAAA,S,aAAA,I,aAiCA,IAAC,W,sBAjCK2F,I,aAEFxF,KAAKC,KAAO,CACVwF,WAAYtF,SAAS0D,cAAc,mBACnC6B,oBAAqBvF,SAAS0D,cAC5B,8CAIJ7D,KAAK2F,uBAAyB,GAE9B3F,KAAKM,c,iBAGPC,IAAA,e,MAAA,WACEP,KAAKC,KAAKwF,WAAW/E,iBAAiB,SAAUV,KAAK4F,SAAS/E,KAAKb,M,IAGrEO,IAAA,W,MAAA,SAASO,GACPA,EAAM+E,iBAEN,IAAMC,EAAO,IAAIC,SAAS/F,KAAKC,KAAKwF,YAE/BO,GAAiB,EAAjBC,GAAiB,EAAjBC,OAAiB9D,E,IAAtB,QAAK+D,EAAAC,EAAqBN,EAAIO,OAAAC,cAAzBN,GAAAG,EAAAC,EAAiBG,QAAAC,MAAjBR,GAAiB,GAAjB,IAAAS,EAAAC,EAAAC,EAAA,CAAAR,EAAiBS,MAAA,GAAZ1F,EAAIuF,EAAA,GAAEG,EAAKH,EAAA,GACnBzG,KAAK2F,uBAAuBzE,GAAQ0F,C,WADjCX,GAAiB,EAAjBC,EAAiBW,C,aAAjBb,GAAiB,MAAjBI,EAAiBU,QAAjBV,EAAiBU,Q,YAAjBb,E,MAAAC,C,EAILpB,QAAQC,IAAI/E,KAAK2F,wBAEjB7E,EAAME,OAAO+F,O,OAIhB,I","sources":["src/index.js","src/js/main_page/benefit.js","src/js/main_page/courses-preview.js","node_modules/throttle-debounce/throttle.js","src/js/common/subscription.js"],"sourcesContent":["import './js/common/header';\r\nimport './js/main_page/benefit';\r\nimport './js/main_page/courses-preview';\r\nimport './js/main_page/team-slider';\r\nimport './js/common/testimonials-slider';\r\nimport './js/common/subscription';\r\nimport './js/common/footer';\r\n","class BenefitsTabs {\r\n  constructor() {\r\n    this.refs = {\r\n      benefitGroups: document.querySelectorAll('.js-benefits-item'),\r\n      tabButtons: document.querySelectorAll('.js-tab-button'),\r\n    };\r\n\r\n    this.addListeners();\r\n  }\r\n\r\n  addListeners() {\r\n    this.refs.tabButtons.forEach(button =>\r\n      button.addEventListener('click', this.selectBenefitGroup.bind(this))\r\n    );\r\n  }\r\n\r\n  selectBenefitGroup(event) {\r\n    const clickedButton = event.target.closest('.js-tab-button');\r\n    this.refs.tabButtons.forEach(button => {\r\n      clickedButton.name !== button.name\r\n        ? button.classList.remove(`clicked`)\r\n        : button.classList.add(`clicked`);\r\n    });\r\n\r\n    this.refs.benefitGroups.forEach(group => {\r\n      clickedButton.name === group.dataset.name\r\n        ? group.classList.remove('is-hidden')\r\n        : group.classList.add('is-hidden');\r\n    });\r\n  }\r\n}\r\n\r\nnew BenefitsTabs();\r\n","import { throttle } from 'throttle-debounce';\r\n\r\nclass AnimateCards {\r\n  constructor() {\r\n    this.refs = {\r\n      coursesList: document.querySelector('.courses-preview__box'),\r\n      coursesCards: document.querySelectorAll('.card-courses__img img'),\r\n    };\r\n\r\n    this.addListener();\r\n    // this.isInViewport();\r\n    // this.animate();\r\n    // this.getRect();\r\n  }\r\n\r\n  addListener() {\r\n    // document.addEventListener(\r\n    //   'scroll',\r\n    //   throttle(1000, this.isInViewport.bind(this))\r\n    // );\r\n    throttle(1000, this.isInViewport.bind(this));\r\n  }\r\n\r\n  isInViewport() {\r\n    const rect = this.refs.coursesList.getBoundingClientRect();\r\n    const isVisible =\r\n      rect.top >= 0 &&\r\n      rect.left >= 0 &&\r\n      rect.bottom <=\r\n        (window.innerHeight || document.documentElement.clientHeight) &&\r\n      rect.right <= (window.innerWidth || document.documentElement.clientWidth);\r\n    console.log(isVisible);\r\n\r\n    let timerId = null;\r\n\r\n    // if (isVisible) {\r\n    //   if (timerId) {\r\n    //     return;\r\n    //   } else {\r\n    //     timerId = setInterval(() => this.animate(), 1000);\r\n    //     console.log('timerId set:', timerId);\r\n    //   }\r\n    // } else {\r\n    //   console.log('timerId clear:', timerId);\r\n    //   clearInterval(timerId);\r\n    // }\r\n\r\n    isVisible\r\n      ? (timerId = setInterval(() => this.animate(), 1000))\r\n      : clearInterval(timerId);\r\n  }\r\n\r\n  getRect() {\r\n    let rect = this.refs.coursesList.getBoundingClientRect();\r\n    console.log(rect.top);\r\n    // if (rect.top < 0) {\r\n    //   return;\r\n    // }\r\n\r\n    // let timerId = null;\r\n\r\n    // rect.top > 0\r\n    //   ? (timerId = setInterval(() => this.animate(), 1000))\r\n    //   : clearInterval(timerId);\r\n\r\n    // if (rect.top > 0) {\r\n    //   if (timerId) {\r\n    //     return;\r\n    //   } else {\r\n    //     timerId = setInterval(() => this.animate(), 1000);\r\n    //   }\r\n    // } else {\r\n    //   clearInterval(timerId);\r\n    // }\r\n\r\n    // console.log(rect.top);\r\n    // if (rect.top > 0) {\r\n    //   this.animate();\r\n    // }\r\n  }\r\n\r\n  // }\r\n  animate() {\r\n    // console.log('scrolling...');\r\n    // let rect = this.refs.coursesList.getBoundingClientRect();\r\n    // console.log('The bounding Rect of element is ', rect);\r\n    // if (rect.top > 0) {\r\n    console.log(Math.floor(Math.random() * this.refs.coursesCards.length));\r\n    // console.log(this.refs.coursesCards.length);\r\n\r\n    const numberOfCardToAnimate = Math.floor(\r\n      Math.random() * this.refs.coursesCards.length\r\n    );\r\n\r\n    // this.refs.coursesCards.forEach(card => {\r\n    // \tconsole.log();\r\n    // })\r\n    // this.animate()\r\n    this.refs.coursesCards[numberOfCardToAnimate].classList.add(\r\n      'scale-animated'\r\n    );\r\n\r\n    setTimeout(() => {\r\n      this.refs.coursesCards[numberOfCardToAnimate].classList.remove(\r\n        'scale-animated'\r\n      );\r\n      // this.animate();\r\n    }, 1000);\r\n  }\r\n  // }\r\n}\r\n\r\nnew AnimateCards();\r\n","/* eslint-disable no-undefined,no-param-reassign,no-shadow */\n\n/**\n * Throttle execution of a function. Especially useful for rate limiting\n * execution of handlers on events like resize and scroll.\n *\n * @param {number} delay -                  A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher)\n *                                            are most useful.\n * @param {Function} callback -               A function to be executed after delay milliseconds. The `this` context and all arguments are passed through,\n *                                            as-is, to `callback` when the throttled-function is executed.\n * @param {object} [options] -              An object to configure options.\n * @param {boolean} [options.noTrailing] -   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds\n *                                            while the throttled-function is being called. If noTrailing is false or unspecified, callback will be executed\n *                                            one final time after the last throttled-function call. (After the throttled-function has not been called for\n *                                            `delay` milliseconds, the internal counter is reset).\n * @param {boolean} [options.noLeading] -   Optional, defaults to false. If noLeading is false, the first throttled-function call will execute callback\n *                                            immediately. If noLeading is true, the first the callback execution will be skipped. It should be noted that\n *                                            callback will never executed if both noLeading = true and noTrailing = true.\n * @param {boolean} [options.debounceMode] - If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is\n *                                            false (at end), schedule `callback` to execute after `delay` ms.\n *\n * @returns {Function} A new, throttled, function.\n */\nexport default function (delay, callback, options) {\n\tconst {\n\t\tnoTrailing = false,\n\t\tnoLeading = false,\n\t\tdebounceMode = undefined\n\t} = options || {};\n\t/*\n\t * After wrapper has stopped being called, this timeout ensures that\n\t * `callback` is executed at the proper times in `throttle` and `end`\n\t * debounce modes.\n\t */\n\tlet timeoutID;\n\tlet cancelled = false;\n\n\t// Keep track of the last time `callback` was executed.\n\tlet lastExec = 0;\n\n\t// Function to clear existing timeout\n\tfunction clearExistingTimeout() {\n\t\tif (timeoutID) {\n\t\t\tclearTimeout(timeoutID);\n\t\t}\n\t}\n\n\t// Function to cancel next exec\n\tfunction cancel(options) {\n\t\tconst { upcomingOnly = false } = options || {};\n\t\tclearExistingTimeout();\n\t\tcancelled = !upcomingOnly;\n\t}\n\n\t/*\n\t * The `wrapper` function encapsulates all of the throttling / debouncing\n\t * functionality and when executed will limit the rate at which `callback`\n\t * is executed.\n\t */\n\tfunction wrapper(...arguments_) {\n\t\tlet self = this;\n\t\tlet elapsed = Date.now() - lastExec;\n\n\t\tif (cancelled) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Execute `callback` and update the `lastExec` timestamp.\n\t\tfunction exec() {\n\t\t\tlastExec = Date.now();\n\t\t\tcallback.apply(self, arguments_);\n\t\t}\n\n\t\t/*\n\t\t * If `debounceMode` is true (at begin) this is used to clear the flag\n\t\t * to allow future `callback` executions.\n\t\t */\n\t\tfunction clear() {\n\t\t\ttimeoutID = undefined;\n\t\t}\n\n\t\tif (!noLeading && debounceMode && !timeoutID) {\n\t\t\t/*\n\t\t\t * Since `wrapper` is being called for the first time and\n\t\t\t * `debounceMode` is true (at begin), execute `callback`\n\t\t\t * and noLeading != true.\n\t\t\t */\n\t\t\texec();\n\t\t}\n\n\t\tclearExistingTimeout();\n\n\t\tif (debounceMode === undefined && elapsed > delay) {\n\t\t\tif (noLeading) {\n\t\t\t\t/*\n\t\t\t\t * In throttle mode with noLeading, if `delay` time has\n\t\t\t\t * been exceeded, update `lastExec` and schedule `callback`\n\t\t\t\t * to execute after `delay` ms.\n\t\t\t\t */\n\t\t\t\tlastExec = Date.now();\n\t\t\t\tif (!noTrailing) {\n\t\t\t\t\ttimeoutID = setTimeout(debounceMode ? clear : exec, delay);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * In throttle mode without noLeading, if `delay` time has been exceeded, execute\n\t\t\t\t * `callback`.\n\t\t\t\t */\n\t\t\t\texec();\n\t\t\t}\n\t\t} else if (noTrailing !== true) {\n\t\t\t/*\n\t\t\t * In trailing throttle mode, since `delay` time has not been\n\t\t\t * exceeded, schedule `callback` to execute `delay` ms after most\n\t\t\t * recent execution.\n\t\t\t *\n\t\t\t * If `debounceMode` is true (at begin), schedule `clear` to execute\n\t\t\t * after `delay` ms.\n\t\t\t *\n\t\t\t * If `debounceMode` is false (at end), schedule `callback` to\n\t\t\t * execute after `delay` ms.\n\t\t\t */\n\t\t\ttimeoutID = setTimeout(\n\t\t\t\tdebounceMode ? clear : exec,\n\t\t\t\tdebounceMode === undefined ? delay - elapsed : delay\n\t\t\t);\n\t\t}\n\t}\n\n\twrapper.cancel = cancel;\n\n\t// Return the wrapper function.\n\treturn wrapper;\n}\n","class AdvertForm {\r\n  constructor() {\r\n    this.refs = {\r\n      advertForm: document.querySelector('.js-advert-form'),\r\n      advertFormMailInput: document.querySelector(\r\n        '.js-advert-form-input[name=\"advertEmail\"]'\r\n      ),\r\n    };\r\n\r\n    this.outputAdvertFormObject = {};\r\n\r\n    this.addListeners();\r\n  }\r\n\r\n  addListeners() {\r\n    this.refs.advertForm.addEventListener('submit', this.onSubmit.bind(this));\r\n  }\r\n\r\n  onSubmit(event) {\r\n    event.preventDefault();\r\n\r\n    const form = new FormData(this.refs.advertForm);\r\n\r\n    for (let [name, value] of form) {\r\n      this.outputAdvertFormObject[name] = value;\r\n    }\r\n\r\n    console.log(this.outputAdvertFormObject);\r\n\r\n    event.target.reset();\r\n  }\r\n}\r\n\r\nnew AdvertForm();\r\n"],"names":["parcelRequire","$8MBJY","BenefitsTabs","this","refs","benefitGroups","document","querySelectorAll","tabButtons","addListeners","key","forEach","button","addEventListener","_this","selectBenefitGroup","bind","event","clickedButton","target","closest","name","classList","remove","add","group","dataset","$d9010ee870d463b5$export$de363e709c412c8a","delay","callback","options","timeoutID","_ref$noTrailing","_ref","noTrailing","_ref$noLeading","noLeading","_ref$debounceMode","debounceMode","undefined","cancelled","lastExec","clearExistingTimeout","clearTimeout","wrapper","_len","arguments","length","arguments_","Array","_key","self","elapsed","Date","now","exec","apply","clear","setTimeout","cancel","_ref2$upcomingOnly","upcomingOnly","AnimateCards","coursesList","querySelector","coursesCards","addListener","isInViewport","rect","getBoundingClientRect","isVisible","top","left","bottom","window","innerHeight","documentElement","clientHeight","right","innerWidth","clientWidth","console","log","timerId","setInterval","animate","clearInterval","Math","floor","random","numberOfCardToAnimate","AdvertForm","advertForm","advertFormMailInput","outputAdvertFormObject","onSubmit","preventDefault","form","FormData","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Symbol","iterator","next","done","_value","$parcel$interopDefault","$1t1Wn","value","err","return","reset"],"version":3,"file":"index.3fb8cb3b.js.map"}